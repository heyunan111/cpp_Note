accumulate : include<numeric> 求和算法，三个参数，前两个指出范围，第三个和的初值
                eg:
                int sum = accumulate(vec.cbegin(),vec.cend(),0);
                sum = vec中元素的和，初值是0
                
                or
                
                string sum = (v.cbegin(),v.cend(),string(""));
                sum = 将v的每个元素连接到一个string上

euql : 比较两个序列是否相同，三个参数，前两个是第一个序列的元素范围，第三个表示第二个序列的首元素
        eg: euql(v1.cbegin(),v1.cend(),v2.cbegin);
        v1可以是vector<int>而v2是list<int>
        或者    vector<string>   list<const char*>

    第二个序列至少与第一个一样长

fill： 赋值
        eg: fill(vec.begin(),vec.end(),0);将每个元素置为0
            fill_n(vec.begin(),vec.size(),0);

back_inserter: 
        eg: vector<int> vec;
            auto it = back_inserter(rec);
            *it = 4;

            or

            fill_n(back_inserter(rec),10,0);

copy: 拷贝算法
        eg:int a[] = {0,1,2,3,4,5,6};
        int b[sizeof(a)/sizeof(*a)];
        auto it = copy(a.begin(),a.end(),b); 第三个参数表示目的序列的起始位置
        it指向拷贝到b的尾元素之后的位置

    多个算法都提供拷贝版本：
        eg: replace_copy(ilist.begin(),ilist.end(),back_inserter(rec),0,42);
        将list的内容拷贝到rec中，并且值为0的元素都变为42

unique: 覆盖相邻的重复元素
        eg:vector<int> vec = {1,1,1,2,3,5,5,5,6};
        auto end_unique = unique(vec.begin(),vec.end());
        此时vec为：1,2,3,5,6, , , , ;
        end_unique指向6之后的第一个元素

for_each :
    vector<int> vec = {1,2,3,5,6,8,9,4};
    for_each(vec.begin(),vec.end(),
    [](const auto &a){cout<<a;}
    );

    12356894