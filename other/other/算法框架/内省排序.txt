内省排序（introsort）是一种高效的排序算法，是快速排序（quicksort）、
堆排序（heapsort）和插入排序（insertion sort）的混合体，它综合了三种排
序算法的优点，并避免了它们的缺点.

#include <iterator>

//找出三个值的中间值
template <class T>
const T& median(const T& left, const T& mid, const T& right)
{
    if (left < mid)
        if (mid < right)        // left < mid < right
            return mid;
        else if (left < right)  // left < right <= mid
            return right;
        else                    // right <= left < mid
            return left;
    else if (left < right)      // mid <= left < right
        return left;
    else if (mid < right)       // mid < right <= left
        return right;
    else                        // right <= mid <= left
        return mid;
}

//求以 2 为底，最接近 n 的对数
template<class Size>
Size slg2(Size n) {
    Size k;
    for (;n > 1; n >>=1)
        ++k;
    return k;
}

//用于快速排序的分割函数。它接受一个区间 [first, last) 和一个 pivot 元素，将区间分为小于等于 pivot
// 的部分和大于 pivot 的部分，并返回一个迭代器，指向小于等于 pivot 部分的最后一个元素的后面一个位置。
template<typename RandomIter, typename T>
RandomIter unckecked_parition(RandomIter first,RandomIter last,const T &pivot) {
    while (true) {
        //找到第一个大于等于pivot的
        while (*first < pivot)
            ++first;
        --last;//防止最后一步的 ++first 操作越界
        //找到第一个小于pivot的
        while (pivot < *last)
            --last;
        if (!(first < last))
            return first;
        std::iter_swap(first,last);
        ++first;
    }
}

///FIXME:heapsort

