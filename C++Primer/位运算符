~:求位反：
    将1置为0，将0置为1
<<，>>:左移右移：
    <<:在右侧插入值为0的二进制位 
    >>:无符号类型：在左侧插入值为0的二进制位；有符号：在左侧插入符号位的副本或值为0的二进制
    位

注意：移位可能会产生溢出。

与，或，异或运算符：
    &：求与
    |：或
    ^:异或

eg: 来自SGI-STL alloc源码：stl_alloc.h,效率高的吓人
    将内存上调整成 8 的倍数
  static size_t ROUND_UP(size_t bytes) {
        return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));
        //这里8是2^3，二进制表示为00001000。前面的0先省略了，不影响分析。
        //_ALIGN-1:
        //00001000->00000111;
        //~_ALIGN-1:
        //00000111->11111000;
        //bytes+ALIGN-1:
        //x这里如果bytes是8的倍数，那么低3位全是0。
        //xxxxx000->xxxxx111
        //(bytes+ALIGN-1)&(~_ALIGN-1):
        //xxxxx111->xxxxx000
        //这里得到的是bytes本身。
        //如果bytes不是8的倍数呢？那么首先
        //8n<bytes<8(n+1)
        //我们要求的就是8(n+1)。
        //bytes用二进制表示，低三位不全为0,加上ALIGN-1会向第4位进位。此时将第三位清零，
        // 使用取反后相与，得到的就是8(n+1)。
        //这里的简单推导一下：
        //8n<bytes<8(n+1)
        //bytes=8n+p,p<8
        //p存在低3位，8n存在高三位，执行加法bytes+ALIGN-1，产生进位。
        //现在bytes=8(n+1)+p,清零后为8(n+1)。
  }