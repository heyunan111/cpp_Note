有三种基本值类别：纯右值，亡值，左值
右值：纯右值或者亡值
左值：非亡值的泛左值
亡值：他的资源能够被重新使用的对象或位域的泛左值

泛左值：其值可以确定某个对象或函数的标识
纯右值：
    计算某个运算符的操作数的值
    初始化某个对象

函数形参永远是左值，即使它的类型是一个右值引用

在运行时，std::move() 和 std::forward() 不会执行任何实际的操作。它们只是在编译时进行类型转换，
以告知编译器在函数调用或转发参数时如何对待参数的引用类型。

std::move除了转换它的实参到右值以外什么也不做
template <typename T>
decltype(auto) move(T &&rhs) {
    return static_cast<remove_referece_t<T>&&>(rhs);
}

std::forward只有当它的参数被绑定到一个右值时,才将参数转换为右值
template <typename T>
[[nodiscard]] constexper T &&forward (typename std::remove_referece_t<T>::type &rhs) noexcept {
    return static_cast<T&&>(rhs);
}

如果一个函数模板形参的类型为T&&，并且T需要被推导得知，或者如果一个对象被声明为auto&&，这个形参或者对象就是一个通用引用。
如果类型声明的形式不是标准的type&&，或者如果类型推导没有发生，那么type&&代表一个右值引用。
通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。

在 C++17 中确实存在需要进行复制消除的情况。其中一个例子是返回值优化、和命名返回值优化。
在这些优化中，编译器会尝试将函数的返回值从函数体内的临时对象直接构造在调用者的对象上，
避免不必要的拷贝或移动操作。这意味着即使在表达式中使用纯右值进行初始化，它们也可能不会被移动，
而是直接构造在目标对象上。

引用折叠发生在四种情况下：模板实例化，auto类型推导，typedef与别名声明的创建和使用，decltype。
当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，
否则就是右值引用。
通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。

完美转发失败的情况：
当模板类型推导失败或者推导出错误类型，完美转发会失败。
导致完美转发失败的实参种类有花括号初始化，作为空指针的0或者NULL，
仅有声明的整型static const数据成员，模板和重载函数的名字，位域。