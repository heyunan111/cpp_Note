注意：
对于单纯常量,最好以const对象或enum替换#defines
对于形似函数的宏,最好改用inline函数替换#defines



eg:以 const double AspectRatio = 1.653 替换 #define ASPECT_RATIO 1.653

"the enum hack"补偿做法:
    class A
    {
        private:
            enum{ NumTurns = 5 };
            int scores(NumTurns);
    };
取一个const的地址合法,但是取一个enum地址不合法 

enum hack的行为更像#define而不是const，如果你不希望别人得到你的常量成员的指针或引用，
你可以用enum hack替代之。（为什么不直接用#define呢？首先，因为#define是字符串替换，所以
不利于程序调试。其次，#define的可视范围难以控制，比如你怎么让#define定义的常量只在一个类
内可见呢？除非你用丑陋的#undef。
使用enum hack不会导致 “不必要的内存分配”。
enum hack是模板元编程的一项基本技术，大量的代码在使用它。当你看到它时，你要认识它。

inline替换#define

eg:
#define CALL_WITH_MAX (a,b) f((a)>(b) ? (a) : (b))
记住为宏中所有实参加上小括号，否则很可能会遇到意想不到的麻烦，纵使如此，也可能会遇到麻烦

template<typename T>
inline void callWithMax(const T& a,const T& b)
{
    f(a > b ? a : b);
}