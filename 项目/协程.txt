ucontext_t 是一个用于保存和切换上下文的数据结构类型，使用它封装协程。  

typedef struct ucontext_t {
    struct ucontext_t *uc_link;
    //指向一个上下文对象，用于保存在当前上下文结束后要切换到的下一个上下文。
    sigset_t uc_sigmask;
    //用于保存当前上下文的信号掩码，即在当前上下文中被阻塞的信号集。
    stack_t uc_stack;
    //用于保存当前上下文的栈信息，包括栈的起始地址和大小。
    mcontext_t uc_mcontext;
    //保存了当前上下文的机器寄存器状态，包括通用寄存器、程序计数器、栈指针等。
    ...
} ucontext_t;


getcontext 函数获取当前上下文，使用 setcontext 函数切换到指定的上下文，或使用 swapcontext 
函数在不同上下文之间切换。

项目实现了有栈协程，有栈协程对比无栈协程速度慢，但是编写简单。
每个线程上运行一个根协程，线程是线程池由线程池管理


如果任务队列中的任务全部处理完毕，协程会创建并切换到idle协程，在idle中，阻塞到 epoll_wait 处进行等待。 
在循环开始时，它使用epoll_wait函数等待事件发生，最多等待MAX_EVENTS个事件。如果有事件发生，
它会遍历事件列表并处理每个事件。
在处理事件之前，它会检查是否有已过期的回调函数（cbs），并将它们加入到调度器中进行执行。

对于每个事件，它会进行一些处理：

如果事件的文件描述符（event.data.fd）是特殊的触发描述符（m_tickleFds[0]），
则读取并忽略数据，继续下一个事件的处理。
否则，它会获取事件关联的文件描述符上下文（FdContext）对象，并锁定该对象的互斥锁。
如果事件表明有错误发生（EPOLLERR或EPOLLHUP），它将添加适当的读写事件（EPOLLIN和EPOLLOUT）
到文件描述符上下文的事件集合中。
接下来，它确定实际发生的事件类型，将其存储在real_events变量中。
如果文件描述符上下文的事件集合与实际发生的事件类型没有交集，说明该事件已经过期或无效，
继续下一个事件的处理。
计算剩余事件（left_events），即文件描述符上下文事件集合与实际发生事件类型的差集。
根据剩余事件来决定epoll_ctl操作的类型，如果还有剩余事件，则使用EPOLL_CTL_MOD修改事件，
否则使用EPOLL_CTL_DEL删除事件。
执行epoll_ctl操作，更新事件。
如果实际发生的事件类型包括读事件（READ），则触发读事件并将计数器m_pendingEventCount减1。
如果实际发生的事件类型包括写事件（WRITE），则触发写事件并将计数器m_pendingEventCount减1。
在事件处理完毕后，通过调用当前协程的swapOut()函数切出当前协程的执行，将控制权切换到其他协程。


epoll_wait
有事件到达：当有事件到达时，epoll_wait函数将返回事件的数量，并将这些事件存储在提供的事件数组中。
程序可以继续处理这些事件。
超时：如果设置了超时时间，即在epoll_wait函数的最后一个参数中指定了一个非负数的超时值，
epoll_wait函数将在超时时间到达之后返回0，表示没有事件到达。程序可以根据需要继续执行其他操作。
错误发生：如果在等待事件期间发生错误，epoll_wait函数将返回-1，并设置errno来指示具体的错误原因。
程序可以根据errno的值进行错误处理。


在协程部分的实现中，你是否考虑了异常处理和错误处理？可以具体描述一下你的处理方式吗？
协程中封装了协程的状态，包括{初始化，暂停，执行中，可执行，结束，异常}，在调度时，如果协程处于异常状态，
则不会进行执行


在协程调度器中，你是否实现了定时器功能或其他调度策略？如果有，可以讲讲具体的实现思路。
IOManger 继承了 TimerManger ，在 TimerManger 中可以添加一次性定时器，循环定时器，条件定时器
定时器中封装了回调函数，将定时器存储在 定时器集合 std::set<Timer::ptr, Timer::Comparator> m_timers 中，
在IOManger idle的时候，会在m_timers中查找定时器过期的任务，并处理
循环定时器：在查找定时器过期的任务的时候，判断是否为循环定时器，如果是，更新下次触发时间为当前时间加上定时
器的间隔时间，并将定时器重新插入定时器容器。
条件定时器：通过创建定时器的时候传入一个weak_ptr弱引用的条件，在定时器结束时会先对条件进行判断，如果条件
满足则调用回调函数


对于项目中的协程部分，你认为有哪些可以改进或优化的地方？有什么想法或建议吗？ 
更改为无栈协程，无栈协程速度更快
 

是否有考虑协程的调试和监控需求？如果有，你是如何实现的？
日志输出：在协程执行过程中加入适当的日志输出，可以在程序运行时查看日志，以便了解协程执行过程中的状态和问题。
调试器：可以使用常见的调试器（如GDB）来调试协程程序，进行断点调试、变量查看等操作。